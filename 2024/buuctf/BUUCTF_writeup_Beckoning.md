# <center>BUUCTF_writeup_by_Beckoning</center>



# Crypto

## 一眼就解密

```
ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=
```

入门，一眼BASE64

解密得

```
flag{THE_FLAG_OF_THIS_STRING}
```



## MD5

```
e00cf25ad42683b3df678c61f42c6bda
```

如题，MD5解密，拿下

```
flag{admin1}
```



## URL编码

```
%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d
```

一眼url

解码得：

```
flag{and 1=1}
```



## 看我回旋踢

```
synt{5pq1004q-86n5-46q8-o720-oro5on0417r1}
```

我们根据前四位去进行分析，前四位应该是对应了flag

我们分析一下，差值相同，一眼凯撒加密，解密得出结果

```
flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1}
```



## 摩丝

```
.. .-.. --- ...- . -.-- --- ..-
```

根据题目给的条件，看出是摩斯密码，解密即可

解出来是ILOVEYOU

得出结果

```
flag{ILOVEYOU}
```



## password

```
姓名：张三 
生日：19900315

key格式为key{xxxxxxxxxx}
```

直接猜测密码就可以了，姓名首字母+生日，得出答案

```
flag{zs19900315}
```



## 变异凯撒

```
加密密文：afZ_r9VYfScOeO_UL^RWUc
格式：flag{ }
```

我们直接猜测，前四位和flag对应

afZ_的ascii码是：97 102 90 95

flag的ascii码是：102 108 97 103

发现，是差值为5,6,7,8

整个密文的ascii码是97 102 90 95 114 57 86 89 102 83 99 79 101 79 95 85 76 94 82 87 85 99

所以，原文的ascii码应该是102 108 97 103 123 67 97 101 115 97 114 95 118 97 114 105 97 116 105 111 110 125

解出flag

```
flag{Caesar_variation}
```



## Quoted-printable

题目是=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6

古典密码，猜测是printable编码，直接解密就行，解出来是：那你也很棒哦

```
flag{那你也很棒哦}
```

**[Quoted-printable在线解密](https://try8.cn/tool/code/qp)**



## Rabbit

题目是U2FsdGVkX1/+ydnDPowGbjjJXhZxm2MP2AgI

是兔子密码，在线解密即可

```
flag{Cute_Rabbit}
```

**[Rabbit解密](https://www.sojson.com/encrypt_rabbit.html)**



## 篱笆墙的影子

题目是felhaagv{ewtehtehfilnakgw}

一眼栅栏密码

设置栏数为13，解出flag

```
flag{wethinkwehavetheflag}
```



## [GXYCTF2019]CheckIn

题目是dikqTCpfRjA8fUBIMD5GNDkwMjNARkUwI0BFTg==

一眼base64，解密得到一串字符，再进行ROT47解密，就可以获得答案

```
flag{Y0u_kNow_much_about_Rot}
```



## Cipher

```
还能提示什么呢？公平的玩吧（密钥自己找） Dncnoqqfliqrpgeklwmppu 注意：得到的 flag 请包上 flag{} 提交, flag{小写字母}
```

这题还需要找密钥，看到这串字符也不知道要干啥

应该是playfair密码

```
flag{itisnotaproblemhavefun}
```



## RSA

```
在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17
求解出d作为flga提交
```

没啥难度，直接解就完事了

解出来d是125631357777427553

```
flag{125631357777427553}
```



## RSA

给了两个文件，一个是key，一个是enc，说明一个是加密文件，一个是解密文件

pub.key文件的内容是:

```
-----BEGIN PUBLIC KEY-----
MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+
/AvKr1rzQczdAgMBAAE=
-----END PUBLIC KEY-----
```

上面的内容是我们的公钥，我们目前无法得知我们的私钥

我们先解析我们的key文件

利用http://tool.chacuo.net/cryptrsakeyparse来解析我们的文件

得到key的长度是256，模数是 C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD，指数是65537

将模数转化为十进制为：86934482296048119190666062003494800588905656017203025617216654058378322103517

**16进制转十进制的python代码是int(x,16)**

然后我们将上面那个数分解为p和q，用质数分解器

285960468890451637935629440372639283459*304008741604601924494328155975272418463

说明

```
p=285960468890451637935629440372639283459
q=304008741604601924494328155975272418463
```

然后我们使用脚本解密就可以了

```python
import gmpy2
import rsa

e = 65537
n = 86934482296048119190666062003494800588905656017203025617216654058378322103517
p = 285960468890451637935629440372639283459
q = 304008741604601924494328155975272418463

phin = (q-1)*(p-1)
d = gmpy2.invert(e, phin)

key = rsa.PrivateKey(n, e, int(d), p, q)

with open("C:\\Users\\10245\\Desktop\\output\\flag.enc", "rb+") as f:
    f = f.read()
    print(rsa.decrypt(f, key))
```

我们可以得到结果

```
flag{decrypt_256}
```



## RSA1

**给p,q,dp,dq,c**

```python
p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852
```

可以看出题目已经把条件都给全了，直接用脚本就OK了

![image-20240406162948743](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240406162948743.png)

```python
import gmpy2 as gp

p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

n = p*q
phin = (p-1)*(q-1)
dd = gp.gcd(p-1, q-1)
d=(dp-dq)//dd * gp.invert((q-1)//dd, (p-1)//dd) * (q-1) +dq
print(d)

m = gp.powmod(c, d, n)

print(m)
print(hex(m)[2:])
print(bytes.fromhex(hex(m)[2:]))
```

运行后得到结果：

![image-20240406161950549](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240406161950549.png)

得到flag：

```python
noxCTF{W31c0m3_70_Ch1n470wn}
```



## RSA2

**给e,n,dp,c**

```
e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657

c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751
```

直接用脚本就OK

![image-20240406162846299](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240406162846299.png)

```python
import gmpy2 as gp

e = 65537
n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113
dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657
c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751

for x in range(1, e):
	if(e*dp%x==1):
		p=(e*dp-1)//x+1
		if(n%p!=0):
			continue
		q=n//p
		phin=(p-1)*(q-1)
		d=gp.invert(e, phin)
		m=gp.powmod(c, d, n)
		if(len(hex(m)[2:])%2==1):
			continue
		print('--------------')
		print(m)
		print(hex(m)[2:])
		print(bytes.fromhex(hex(m)[2:]))
```

得到结果：

```
flag{wow_leaking_dp_breaks_rsa?_98924743502}
```



## RSA3

**给了c1，c2，e1，e2，n——共模攻击**

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240406163322510.png" alt="image-20240406163322510" style="zoom:67%;" />

```
c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361

n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801

e1=11187289

c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397

e2=9647291
```

使用脚本就OK

```python
import gmpy2 as gp
def egcd(a, b):
	if a == 0:
		return (b, 0, 1)
	else:
		g, y, x = egcd(b % a, a)
		return (g, x - (b // a) * y, y)

n = 22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
c1 = 22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
c2 = 18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
e1 = 11187289
e2 = 9647291
s = egcd(e1, e2)
s1 = s[1]
s2 = s[2]
if s1<0:
	s1 = - s1
	c1 = gp.invert(c1, n)
elif s2<0:
	s2 = - s2
	c2 = gp.invert(c2, n)

m = pow(c1,s1,n)*pow(c2,s2,n) % n
print(hex(m)[2:])
print(bytes.fromhex(hex(m)[2:]))

```

解出结果：

```
flag{49d91077a1abcb14f1a9d546c80be9ef}
```



## Dangerous RSA

```
#n:  0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L
#e:  0x3
#c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365
so,how to get the message?
```

这个题使用了**低指数加密攻击**，因为e的值很小，所以不需要进行求逆元，直接用iroot开方即可

代入解密脚本

```python
from gmpy2 import iroot
import libnum
n=0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793
c=0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365
k = 0
while 1:
    res = iroot(c+k*n,3)  #c+k*n 开3次方根 能开3次方即可
    if(res[1] == True):
        print(libnum.n2s(int(res[0]))) #转为字符串
        break
    k=k+1
```

得到结果：

```
flag{25df8caf006ee5db94d48144c33b2c3b}
```



## [HDCTF2019]basic rsa

```python
import gmpy2
from Crypto.Util.number import *
from binascii import a2b_hex,b2a_hex

flag = "*****************"

p = 262248800182277040650192055439906580479
q = 262854994239322828547925595487519915551

e = 65533
n = p*q

c = pow(int(b2a_hex(flag),16),e,n)

print c

# 27565231154623519221597938803435789010285480123476977081867877272451638645710
```

这题的思路就是，用RSA传统方式做，用两个公式，先求出逆元d，正着解出密文m，再用libnum函数来求解最后的字符串

```python
from gmpy2 import *
import libnum
import gmpy2
c=27565231154623519221597938803435789010285480123476977081867877272451638645710
p = 262248800182277040650192055439906580479
q = 262854994239322828547925595487519915551
n=p*q
e=65533
phi=(p-1)*(q-1)
d=invert(e,phi)
m=pow(c,d,n)
print(m)
print(libnum.n2s(2077392566271395359695912870032509))
```

就可以解出来flag了

```
flag{B4by_Rs4}
```

求逆元：

```python
phi=(p-1)*(q-1)
d=invert(e,phi)
```

介绍一下libnum库：

```python
import libnum

#字符串转十进制
s="flag{123}"
print(libnum.s2n(s))

#十进制转字符串
j=1889377532526015427453
print(libnum.n2s(j))

#十六进制转字符串
n=0x666c61677b3132337d
print(libnum.n2s(n))

#字符串转十六进制
print(hex(libnum.s2n("flag{123}")))

#二进制转字符串
b='01100001011000110110001001100100'
print(libnum.b2s(b))

#字符串转二进制
s = 'acbd'
print(libnum.s2b(s))

#数字转二进制串
# n=0xfff
# print(s2b(n2s(n)))

#因数分解:返回n的所有素因子及每个素因子的个数。
print(libnum.factorize(1024))

#任意进制转为十进制
print(int('01111',2))
print(int('0x64',16))
```



## rsa2

```python
N = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471
e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085

import hashlib
flag = "flag{" + hashlib.md5(hex(d)).hexdigest() + "}"

```

这题一眼先把n分解为p和q，然后直接套用公式就出结果了

注意得到的hex值需要在后面加上一个L，这样就转化成了十六进制的类型，再进行计算即可，得到flag

```
flag{47bf28da384590448e0b0d23909a25a4}
```



## RSA5

```
m = xxxxxxxx
e = 65537
========== n c ==========
n = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207
c = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320

......
```

一眼是广播攻击，获得很多组n和c，这样就可以进行hastad广播攻击了，就是**低加密指数攻击**

```python
n=[n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19]
c=[c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19]

for i in range(len(n)):
    for j in range(len(n)):
        if(i!=j):
            if(gmpy2.gcd(n[i],n[j])!=1):   #对不同的n进行 欧几里得算法，以求出最大公约数(p)
                print(i,j)                 #输出对应的n的序号            
                p = gmpy2.gcd(n[i],n[j])
                print("p = ",p)
                q = n[i] // p
                print("q = ",q)
                d = gmpy2.invert(e , (p-1)*(q-1))
                print("d = ",d)
                m = pow(c[i],d,n[i])
                print("m = ",m)
```

得出结果，m=13040004482825176402070107903979416267670062118522537076883968693524598900675425175282673277

```python
print(libnum.n2s(int(m)))
#b'flag{abdcbe5fd94e23b3de429223ab9c2fdf}'
```

于是得出结果：

```
flag{abdcbe5fd94e23b3de429223ab9c2fdf}
```



## [第七章 CTF之CRYPTO章]KeyBoard

```
hjmb 2wq ghnv 90plki 90plki iol,mj -=]';p 0-[;lo qwsz wedxza wedxza 23esaq 90plki  45tfde erfcxs =\'[
```

是古典密码，用键盘进行加密了，我们对应到键盘上，读取出每一个字符。

```
n1book{password}
```



## [第七章 CTF之CRYPTO章]N1DES

```python
# -*- coding: utf-8 -*-
import hashlib,base64
def f(a,b):
    digest = hashlib.sha256(a + b).digest()
    return digest[:8]

def str_xor(a,b):
    return ''.join( chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))

def round_add(a, b):
    res = str_xor(f(a,b),f(b,a))
    return res

def permutate(table, block):
    return list(map(lambda x: block[x], table))

def str_permutate(table, block):
    t = map(lambda x: block[x], string_to_list(table))
    return ''.join(chr(i) for i in t)

def string_to_bits(data):
    data = [ord(c) for c in data]
    l = len(data) * 8
    result = [0] * l
    pos = 0
    for ch in data:
        for i in range(0,8):
            result[(pos<<3)+i] = (ch>>i) & 1
        pos += 1
    return result

def string_to_list(data):
    a = []
    a.extend(ord(i) for i in data)
    return a

s_box = [55, 87, 54, 131, 139, 71, 3, 147, 34, 212, 231, 22, 170, 230, 154, 112, 81, 225, 218, 246, 227, 23, 8, 114, 65, 111, 189, 202, 136, 250, 179, 60, 177, 28, 166, 151, 50, 224, 25, 152, 221, 219, 242, 27, 115, 93, 208, 153, 35, 162, 30, 191, 105, 140, 129, 243, 245, 186, 132, 6, 41, 63, 254, 249, 165, 217, 49, 21, 210, 241, 159, 188, 44, 200, 37, 67, 144, 197, 205, 232, 211, 69, 80, 160, 252, 84, 76, 158, 173, 157, 204, 79, 62, 86, 237, 38, 171, 51, 17, 229, 148, 39, 43, 196, 103, 57, 142, 77, 155, 46, 45, 164, 91, 133, 16, 161, 141, 190, 47, 116, 26, 207, 61, 72, 137, 56, 104, 176, 2, 75, 123, 100, 236, 9, 180, 203, 183, 128, 13, 124, 89, 58, 83, 182, 201, 233, 175, 130, 122, 52, 138, 220, 29, 178, 213, 145, 113, 127, 174, 7, 167, 214, 146, 98, 48, 14, 194, 156, 42, 206, 110, 235, 238, 18, 4, 96, 228, 149, 0, 253, 101, 107, 119, 32, 117, 134, 92, 53, 193, 94, 90, 172, 143, 185, 244, 199, 109, 102, 15, 85, 11, 209, 251, 10, 163, 12, 120, 222, 255, 126, 226, 135, 40, 192, 150, 215, 240, 99, 1, 97, 64, 36, 248, 82, 234, 68, 70, 184, 125, 198, 31, 5, 73, 187, 118, 106, 239, 169, 74, 95, 24, 20, 223, 19, 33, 78, 216, 168, 108, 59, 88, 247, 195, 66, 181, 121]

def generate(o):
    k = permutate(o,s_box)
    b = []
    for i in range(0, len(k), 7):
        b.append(k[i:i+7] + [1])
    c = []
    for i in range(32):
        pos = 0
        x = 0
        for j in b[i]:
            x += (j<<pos)
            pos += 1
        c.append((0x10001**x) % (0x7f))
    return permutate(o,s_box)



class N1ES_2:
    def __init__(self, key):
        if len(key) != 32 :
            raise Exception("key must be 32 bytes long")
        self.key = key
        self.gen_subkey()

    def gen_subkey(self):
        o = string_to_bits(self.key)
        k = []
        for i in range(8):
            o = generate(o)
            k.extend(o)
            o = string_to_bits([chr(c) for c in o[0:32]])
        self.Kn = []
        for i in range(32):
            t = map(chr, k[i * 8: i * 8 + 8])
            self.Kn.append(''.join(i for i in t))
        return

    def encrypt(self, plaintext):
        if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False):
            raise Exception("plaintext must be a multiple of 16 in length")
        res = ''
        for i in range(len(plaintext) / 16):
            block = plaintext[i * 16:(i + 1) * 16]
            L = block[:8]
            R = block[8:]
            for round_cnt in range(32):
                L, R = R, str_xor(round_add(R, self.Kn[round_cnt]),L)
                L, R = str_permutate(L,s_box) , str_permutate(R,s_box)
            L, R = R, L
            res += L + R
        return res


key = "7056b257805ec2b8325795b0e6061f89"
n1es = N1ES_2(key)
cipher = n1es.encrypt(FLAG)
print base64.b64encode(cipher)  # TZPvbvJQ8l2T7G5NmrlDWPLoymq2See29B16+/xf+qk=
```



## 丢失的MD5

```python
import hashlib   
for i in range(32,127):
    for j in range(32,127):
        for k in range(32,127):
            m=hashlib.md5()
            m.update('TASC'+chr(i)+'O3RJMV'+chr(j)+'WDJKX'+chr(k)+'ZM')
            des=m.hexdigest()
            if 'e9032' in des and 'da' in des and '911513' in des:
                print des
```

































































































# Misc

## 签到

直接输入flag就可以了

```
flag{buu_ctf}
```

