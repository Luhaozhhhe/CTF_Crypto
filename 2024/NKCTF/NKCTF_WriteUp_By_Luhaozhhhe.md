# NKCTF_WriteUp_By_Luhaozhhhe

# Result

<img src="C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240901221307144.png" alt="image-20240901221307144" style="zoom:50%;" />

![image-20240901221328789](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240901221328789.png)

![image-20240901221344063](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240901221344063.png)



## Crypto

### 1_do_u_know_rot13(14 solves,154 points)

```
ATHtATVtAQZtAGDtAQLtA2VtAGZtAwxtAwptAzHtAJLtAQxtAzHtAJLtAwVtZmxtZmHtZmZtZmttZmNtZmRtAwLtA2D=
```

根据题目提示，是经典的rot13加密

解密得

```
NGUgNGIgNDMgNTQgNDYgN2IgNTMgNjkgNjcgNmUgNWYgNDkgNmUgNWYgNjIgMzkgMzUgMzMgMzggMzAgMzEgNjYgN2Q=
```

感觉像base64

脱一层，得到`4e 4b 43 54 46 7b 53 69 67 6e 5f 49 6e 5f 62 39 35 33 38 30 31 66 7d`

一眼ascii

ascii解密得到flag

```
NKCTF{Sign_In_b953801f}
```



### 2_ez_mod(5 solves,302 points)

文件内容为`daa66f47a3f5668484b8bb01b250b88a530159b232beb21f81be2bc4`

```python
import sys
key = '------unkonw----'
flag = 'NKCTF{----unkown-----}'

if len(key) % 2 != 0:
    print("Error,illegal key length")
    sys.exit(1)

ciphertext = ''
for each in flag:
    for i in range(0,int(len(key)/2)):
        temp = (ord(key[i*2]) * ord(each) + ord(key[i*2+1])) % 251
    ciphertext += '%02x' % temp

print(ciphertext)
```

发现关键加密步骤是

```python
for each in flag:
    for i in range(0,int(len(key)/2)):
        temp = (ord(key[i*2]) * ord(each) + ord(key[i*2+1])) % 251
    ciphertext += '%02x' % temp
```

我们知道取模是不可逆的，所以我们没法倒着解密

采用爆破的形式，我们猜测flag的前两位是NK

那么我们的密文中的da和a6分别就对应了我们的N和K

无脑爆破即可

```python
temp1 = int('da', 16)
for x in range(32,126):
    for y in range(32,126):
        if (x*78 + y) % 251 == temp1:
            with open('1.txt', 'a') as f1:
                f1.write(f"{x}\t{y}\n")

temp2 = int('a6', 16)
for x in range(32,126):
    for y in range(32,126):
        if (x*75 + y) % 251 == temp2:
            with open('2.txt', 'a') as f2:
                f2.write(f"{x}\t{y}\n")
```

将两个输出的文件相比较，发现两者相同的部分为101,121

```python
ciphertext = "daa66f47a3f5668484b8bb01b250b88a530159b232beb21f81be2bc4"
for i in range(0, len(ciphertext), 2):
    fl = ciphertext[i: i+2]
    fl = int(fl, 16)
    for flag in range(32, 126):
        if fl == (101 * flag + 121) % 251:
            print(chr(flag), end='')
```

解密即可，得到flag（仿射密码确实easy）

```
NKCTF{4ffin3_ciph3r_1s_easy}
```



### 3_ez_shamir(5 solves,302 points)

```
p = 0xe4fa76fb77c30f889bbab54d7d7a3e7edbd7ae6c42a1a443f657e95c5708fa15

(1, 0x97b7266eb7157a8328c2aefe29ac42786bebff6fa49dc9385aaaf0d04eb71fdb)
(3, 0x74a04c8d99b4213fbb346f736ce14c6dd450d70565eed5db2bbecc2bda38ff2e)
(5, 0xf1ee8c8818da5ce617da5065c921ada64f492cd823f9495f207e8af1963b268)
(7, 0xa2b1bdc65ba2b08ea56506d4def8dce068ab95ff461322d6486b1f57f8ceceba)
(9, 0xa598ea9e2e5a391e57eb4619af2bd20dc90f110c01ee05cdfce24a4296088ef8)
```

一看感觉没啥头绪，然后看了一眼题干，发现是shamir密钥体系，之前还没有接触过

上网搜一搜对应的知识点，结果直接出脚本了

```python
from decimal import Decimal
import gmpy2
import libnum
p =103569862428807273390153924605612763892112324827076587783912777922937702906389
m = ((1, 68622838400163965548693064122533174233246009303816555390487324018175789965275),
     (3, 52751514316285160454498808951897012007282475479591594114695310715785628417838),
     (5, 6839304751477692297554182388670780684032679137087185355747018272523891749480),
     (7,73588723178734257648107175624749221815414333657719386539097038360574342123194),
     (9,74901800043283471956653196038641520734689046445445817934456611685852881915640))
r=0
for i in range(5):
    ans=m[i][1]
    rev=1
    for j in range(5):
        if(i!=j):
            ans*=(0-m[j][0])
            rev*=(m[i][0]-m[j][0])
    temp=gmpy2.invert(rev,p)*ans
    r+=int(temp)
    r=r%p
r=r%p

print(libnum.n2s(int(r)))
```

把数字直接一换就出结果了(bushi

```
NKCTF{shamir_is_funny_aeb7b49d}
```



### 4_好大的E呀(4 solves,346 points)

```python
from secret import flag
from Crypto.Util.number import *
m = bytes_to_long(flag)

p = getPrime(512)
q = getPrime(512)
N = p * q
phi = (p-1) * (q-1)
while True:
    d = getRandomNBitInteger(200)
    if GCD(d, phi) == 1:
        e = inverse(d, phi)
        break

c = pow(m, e, N)

print(c, e, N, sep='\n')

# 50731930772069400686916575246743443452690899444379694434142743274443218674216786100592969492035838858975790362301326716271359037068440695787843304326121973378828669353495488413292658283250319806410452561159285186453240700403006071553564128311178986134537345710296723446835100780095050029782699880797001290585
# 125619605854511237269883683031391390653132922696055190790276366165477690100535077869013396660811953029595192335898397954255200805873910433163903845670979504404026030359433123685368532858699572759217166389863783629130327509871695226910573050313927188416593083574670460643869373616920128694339874731859790544747
# 128216550721871953992837401168487712446571832164773495937413965460678888368402993356042919515750740340152446678834773547343464951187081474401459704326412662982617641938704869418542453910363454470595033146721287218097966251455246701380660582645862052493991746737373581632846045108023823704823323628291586628263
```

看到e很大，一眼wiener attack

板子题，一秒出

```python

def wienerAttack(N, e):
    """
    维纳攻击

    `Parameters`:
        N - p * q\\
        e - public key
    
    `Returns`:
        p, q, d
    """
    cf = continued_fraction(e / N)
    convers = cf.convergents()
    for pkd in convers:
        # possible k, d
        pk, pd = pkd.as_integer_ratio()
        if pk == 0:
            continue
        
        # verify
        if (e * pd - 1) % pk != 0:
            continue
        
        # possible phi
        pphi = (e * pd - 1) // pk
        p = var('p', domain=ZZ)
        roots = solve(p ** 2 + (pphi - N - 1) * p + N, p)
        if len(roots) == 2:
            # possible p, q
            pp, pq = roots
            if pp * pq == N:
                return pp, pq, pd
    raise ValueError('Could not factor N!')

N = 128216550721871953992837401168487712446571832164773495937413965460678888368402993356042919515750740340152446678834773547343464951187081474401459704326412662982617641938704869418542453910363454470595033146721287218097966251455246701380660582645862052493991746737373581632846045108023823704823323628291586628263
e = 125619605854511237269883683031391390653132922696055190790276366165477690100535077869013396660811953029595192335898397954255200805873910433163903845670979504404026030359433123685368532858699572759217166389863783629130327509871695226910573050313927188416593083574670460643869373616920128694339874731859790544747
c = 50731930772069400686916575246743443452690899444379694434142743274443218674216786100592969492035838858975790362301326716271359037068440695787843304326121973378828669353495488413292658283250319806410452561159285186453240700403006071553564128311178986134537345710296723446835100780095050029782699880797001290585
p, q, d = wienerAttack(N, e)
m = pow(c, d, N)
print(m)
```

得到m的值：9065825384554638265187506134381503724563317832732677909868256490603388710631549

long_to_bytes得到flag

```
NKCTF{rsa-wiener-attack-d3752538}
```



### 5_rotate(4 solves,580 points)

```python
import random
from secret import flag

ror = lambda x, l, b: (x >> l) | ((x & ((1<<l)-1)) << (b-l))

N = 1
for base in [2, 3, 7]:
    N *= pow(base, random.randint(123, 456))
e = random.randint(271828, 314159)

m = int.from_bytes(flag, byteorder='big')
assert m.bit_length() < N.bit_length()
a=[]
for i in range(m.bit_length()):
    a.append(pow(ror(m, i, m.bit_length()), e, N))
with open('chall.txt', 'w') as file:
    for num in a:
        file.write(str(num) + '\n') 
```

题目有点难懂，丢到gpt让他看看（

![image-20240828211547824](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240828211547824.png)

我们发现我们需要的结果和我们输出的c的值是一一对应的，根据每次pow得到的结果都能确定出我们的一位flag

```python
from Crypto.Util.number import *
from Crypto.PublicKey.RSA import * 


with open(r'.\chall.txt','r+') as f:
    cipher = f.readlines()

m = ""
for s in cipher:
    s = int(s,10)
    if s%2 == 1 :
        m += "1"
    else:
        m += "0"

m = int(m[::-1],2)
print(long_to_bytes(m))
```

得到flag

```
NKCTF{0h_1t_l34ks_th3_l34st_s1gn1f1c4nt_b1t}
```



### 6_rsa_chall(3 solves,656 points)

```python
from flag import text,flag
import md5
from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime

assert md5.new(text).hexdigest() == flag[6:-1]

msg1 = text[:xx]
msg2 = text[xx:yy]
msg3 = text[yy:]

msg1 = bytes_to_long(msg1)
msg2 = bytes_to_long(msg2)
msg3 = bytes_to_long(msg3)

p1 = getPrime(512)
q1 = getPrime(512)
N1 = p1*q1
e1 = 3
print pow(msg1,e1,N1)
print (e1,N1)

p2 = getPrime(512)
q2 = getPrime(512)
N2 = p2*q2
e2 = 17
e3 = 65537
print pow(msg2,e2,N2)
print pow(msg2,e3,N2)
print (e2,N2)
print (e3,N2)

p3 = getPrime(512)
q3 = getPrime(512)
N3 = p3*q3
print pow(msg3,e3,N3)
print (e3,N3)
print p3>>200
```

简单分析一下，分为三个部分

第一部分是一个低指数解密攻击，e=3

第二部分是一个广播攻击，n和msg相同，c和e变化

第三部分就是一个简单的coppersmith的p的高位攻击

task1：

```python
#task1
from gmpy2 import *
c1=19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893
e1=3
n1=123814470394550598363280518848914546938137731026777975885846733672494493975703069760053867471836249473290828799962586855892685902902050630018312939010564945676699712246249820341712155938398068732866646422826619477180434858148938235662092482058999079105450136181685141895955574548671667320167741641072330259009
for i in range(200000000):
    if gmpy2.iroot(c1+n1*i,3)[1]==1:
        res=gmpy2.iroot(c1+n1*i,3)[0]
        print (i,res)

        break
```

通过上面的脚本解出msg1

```
msg1=267334379257781603687613466720913534310764480084016847281446486946801530200295563483353634338157
```

task2：

```python
#task2
import gmpy2 as gp
def egcd(a, b):
	if a == 0:
		return (b, 0, 1)
	else:
		g, y, x = egcd(b % a, a)
		return (g, x - (b // a) * y, y)
n = 111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977
c1 = 54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610
c2 = 91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950
e1 = 17
e2 = 65537
s = egcd(e1, e2)
s1 = s[1]
s2 = s[2]
if s1<0:
	s1 = - s1
	c1 = gp.invert(c1, n)
elif s2<0:
	s2 = - s2
	c2 = gp.invert(c2, n)

m = pow(c1,s1,n)*pow(c2,s2,n) % n
print(m)
```

得到msg2

```
msg2=4193305853284549103821195807609492624095031428085219879448342104337322945001387680236011960472296815293233144303730273979905837762067652913308898433728800864776794638198055607422503065410595894676740531680367227696622352026247676452540064020322619036125381146346603655445487695574824919137
```

task3：

```python
#task3
c=59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646
e=65537
n=113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147
p_high200=7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902

#Sage
n = 
p4 =  #p去0的剩余位
pbits = 1024
kbits = pbits - p4.nbits()
print(p4.nbits())
p4 = p4 << kbits
PR.<x> = PolynomialRing(Zmod(n))
f = x + p4
roots = f.small_roots(X=2^kbits, beta=0.4)
if roots:        
    p = p4 + int(roots[0])
    q = n//p
    print(f'n: {n}')
    print(f'p: {p}')
    print(f'q: {q}')
```

先解出p和q，然后正常rsa解密就可以了

```python
p=11437038763581010263116493983733546014403343859218003707512796706928880848035239990740428334091106443982769386517753703890002478698418549777553268906496423
q=9918033198963879798362329507637256706010562962487329742400933192721549307087332482107381554368538995776396557446746866861247191248938339640876368268930589
n=p*q
from gmpy2 import *
from Crypto.Util.number import *
phi=(p-1)*(q-1)
c=59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646
e=65537
d=invert(e,phi)
m=pow(c,d,n)
print(m)
```

得到m，再字符转化得msg3

```
msg3=978430871477569051989776547659020359721056838635797362474311886436116962354292851181720060000979143571198378856012391742078510586927376783797757539078239088349758644144812898155106623543650953940606543822567423130350207207895380499638001151443841997176299548692737056724423631882
```

然后把三部分合在一起，直接反套md5就出flag了

```python
msg1=267334379257781603687613466720913534310764480084016847281446486946801530200295563483353634338157
msg2=4193305853284549103821195807609492624095031428085219879448342104337322945001387680236011960472296815293233144303730273979905837762067652913308898433728800864776794638198055607422503065410595894676740531680367227696622352026247676452540064020322619036125381146346603655445487695574824919137
msg3=978430871477569051989776547659020359721056838635797362474311886436116962354292851181720060000979143571198378856012391742078510586927376783797757539078239088349758644144812898155106623543650953940606543822567423130350207207895380499638001151443841997176299548692737056724423631882
flag = long_to_bytes(msg1)+long_to_bytes(msg2)+long_to_bytes(msg3)


from Crypto.Util.number import *

import hashlib
print(hashlib.md5(flag).hexdigest())
```

flag：

```
NKCTF{3943e8843a19149497956901e5d98639}
```



### 7_xor&rox(4 solves,580 points)

```python
from Crypto.Util.number import *
from hashlib import md5

a = getPrime(512)
b = getPrime(512)
c = getPrime(512)
d = getPrime(512)
d1 = int(bin(d)[2:][::-1] , 2)
n1 = a*b
x1 = a^b
n2 = c*d
x2 = c^d1
flag = md5(str(a+b+c+d).encode()).hexdigest()
print("n1 =",n1)
print("x1 =",x1)
print("n2 =",n2)
print("x2 =",x2)

#n1 = 83876349443792695800858107026041183982320923732817788196403038436907852045968678032744364820591254653790102051548732974272946672219653204468640915315703578520430635535892870037920414827506578157530920987388471203455357776260856432484054297100045972527097719870947170053306375598308878558204734888246779716599
#x1 = 4700741767515367755988979759237706359789790281090690245800324350837677624645184526110027943983952690246679445279368999008839183406301475579349891952257846
#n2 = 65288148454377101841888871848806704694477906587010755286451216632701868457722848139696036928561888850717442616782583309975714172626476485483361217174514747468099567870640277441004322344671717444306055398513733053054597586090074921540794347615153542286893272415931709396262118416062887003290070001173035587341
#x2 = 3604386688612320874143532262988384562213659798578583210892143261576908281112223356678900083870327527242238237513170367660043954376063004167228550592110478
```

看到这两行代码`n1 = a*b x1 = a^b`

肯定是爆破求解，我们从低位开始爆破即可

```python
import itertools

n1 = 83876349443792695800858107026041183982320923732817788196403038436907852045968678032744364820591254653790102051548732974272946672219653204468640915315703578520430635535892870037920414827506578157530920987388471203455357776260856432484054297100045972527097719870947170053306375598308878558204734888246779716599
x1 = 4700741767515367755988979759237706359789790281090690245800324350837677624645184526110027943983952690246679445279368999008839183406301475579349891952257846

a_list, b_list = [0], [0]

cur_mod = 1
for i in range(720):
    cur_mod *= 2
    nxt_as, nxt_bs = [], []
    for al, bl in zip(a_list, b_list):
        for ah, bh in itertools.product([0, 1], repeat=2):
            aa, bb = ah*(cur_mod // 2) + al, bh*(cur_mod // 2) + bl
            if ((aa * bb % cur_mod == n1 % cur_mod) and ((aa ^ bb) == x1 % cur_mod)):
                nxt_as.append(aa)
                nxt_bs.append(bb)
    
    a_list, b_list = nxt_as, nxt_bs

for a, b in zip(a_list, b_list):
    if a * b == n1 and a*b-n1==0 and (a^b)-x1==0:
        break

print(a)
print(b)
#7836147139610655223711469747200164069484878894626166870664740637786609468164555354874619497753277560280939259937394201154154977382033483373128424196987617
#10703774182571073361112791376032380096360697926840362483242105878115552437021674861528714598089603406032844418758725744879476596359225265333530235803365847

```

这样我们就得到了a和b的值

然后根据下两行我们再求解我们的c和d就可以了，也是有脚本

```python
import itertools
 
n1 = 65288148454377101841888871848806704694477906587010755286451216632701868457722848139696036928561888850717442616782583309975714172626476485483361217174514747468099567870640277441004322344671717444306055398513733053054597586090074921540794347615153542286893272415931709396262118416062887003290070001173035587341
 
x1 = 3604386688612320874143532262988384562213659798578583210892143261576908281112223356678900083870327527242238237513170367660043954376063004167228550592110478
 
cl_list, dl_list, ch_list, dh_list = [1], [1], [1], [1]
 
x1_bits = [int(x) for x in f'{x1:0512b}'[::-1]]
print(x1_bits)
print('\n')
mask = 2
for i in range(1,256):
    mask*=2
    scl_list, sdl_list, sch_list, sdh_list = [], [], [], []
    for j in range(len(cl_list)):
        for cl in range(2):
            for dl in range(2):
                for ch in range(2):
                    for dh in range(2):
                        if (cl ^ dh == x1_bits[511-i] and ch ^ dl == x1_bits[i]):
                            temp1 = ((mask // 2 * cl + cl_list[j]) * (mask // 2 * dl + dl_list[j]))%mask
                            temp2 = n1 % mask
                            if (temp1 == temp2):
                                g1 = bin(ch_list[j])[2:] + bin(ch)[2:] + '1' * (510 - 2 * i) + bin(cl)[2:] + bin(cl_list[j])[2:].zfill(i)
                                g1 = int(g1, 2)
                                g2 = bin(dh_list[j])[2:] + bin(dh)[2:] + '1' * (510 - 2 * i) + bin(dl)[2:] + bin(dl_list[j])[2:].zfill(i)
                                g2 = int(g2, 2)
                                if(g1 * g2 < n1):
                                    continue
                                g1 = bin(ch_list[j])[2:] + bin(ch)[2:] + '0' * (510 - 2 * i) + bin(cl)[2:] + bin(cl_list[j])[2:].zfill(i)
                                g1 = int(g1, 2)
                                g2 = bin(dh_list[j])[2:] + bin(dh)[2:] + '0' * (510 - 2 * i) + bin(dl)[2:] + bin(dl_list[j])[2:].zfill(i)
                                g2 = int(g2, 2)
                                if (g1 * g2 > n1):
                                    continue
                                scl_list.append(mask // 2 * cl + cl_list[j])
                                sch_list.append(ch_list[j]*2 + ch)
                                sdl_list.append(mask // 2 * dl + dl_list[j])
                                sdh_list.append(dh_list[j] * 2 + dh)
    cl_list,dl_list,ch_list,dh_list = scl_list,sdl_list,sch_list,sdh_list
 
print(cl_list)
print(dl_list)
print(ch_list)
print(dh_list)
 
 
 
 
d=int(bin(ch_list[0])[2:]+bin(cl_list[0])[2:].zfill(256),2)
c=int(bin(dh_list[0])[2:]+bin(dl_list[0])[2:].zfill(256),2)
 
print(c)
print(d)
print(c * d - n1)
print(((c ^ int(bin(d)[2:][::-1],2)) - x1))
 
a=7836147139610655223711469747200164069484878894626166870664740637786609468164555354874619497753277560280939259937394201154154977382033483373128424196987617
b=10703774182571073361112791376032380096360697926840362483242105878115552437021674861528714598089603406032844418758725744879476596359225265333530235803365847
c=8046925436710204192438304055874778865895416996970843869698858865603953411170369526997784224210491769140388046960966644628154489203286940293881427188058327
d=8113427789020078526682817916943942153489187786107307958765586032610741354289280539264853469783621315049385549884903133806294183614352084988365109630250683
print(bin(c ^ int(bin(d)[2:][::-1],2)))
import hashlib
flag = hashlib.md5(str(a+b+c+d).encode()).hexdigest()
print("NKCTF{%s}"%flag)
```

得到flag

```
NKCTF{f28ed218415356b4336e2f778f2981bb}
```



### 8_easy_lwe(3 solves,907 points)

```python
from Crypto.Util.number import *
from secrets import flag
assert len(flag) == 38
t = 30
p = getPrime(512)
x = getPrime(512)
while x > p:
    x = getPrime(512)
rs = []
cs = []
ss = []
for i in range(t):
    r = getPrime(512)
    s = getPrime(400)
    c = (r * x + s) % p
    rs.append(r)
    cs.append(c)
    ss.append(s)

enc = pow(x,flag,p)
print(f'p = {p}')
print(f'rs = {rs}')
print(f'cs = {cs}')
print(f'enc = {enc}')
```

发现很明显是拼接题，前半部分是lwe attack，后半部分就是一个光滑的离散对数问题求解

直接用脚本拼接就解决了这个问题

```python
from sage.modules.free_module_integer import IntegerLattice
from Crypto.Util.number import *
import hashlib
row = 30
column = 1
p = 6897108443075981744484758716081045417854227543713106404294789655180105457499042179717447342593790180943415014044830872925165163457476209819356694244840079
rs = [12844634549263053228759749264403637022740290008286987401585068952741935277415527678380021212624846722242500708422759563558995936977274580301379494195702461, 12251634003683452916928102291170339939586644029776192301741341674585154859358419625191986830852794085541953563738986709807899575511700135958334229151930861, 7051370666077542197248638013011793824477073777322219545882367881807130066168444134964571398112151848834032654978368255218649720738040945429837692857031957, 9773046862351952930368505593284546267554571295872377323111558071278701231472975791962979256551519533723988556870551885073742407630481198192389750289392107, 8883776497660138308720006912582738672888752344326928153810910221453595077711284302041512529457450211602787210761461172326429880594024187025419873043435877, 12056735137145460036580841038332100311160368843873164649606343042416896898793233249873902218683966283969721460087390120622254758027779960740926123005377571, 8819958747150954554494406068232243249186433676383469322817152210037563032056202909377825740775383087605647374150477096718956454225946093710691864988563109, 12246023449098354751049599873213988024512286270964608502444597112110163392131757813461977030270733012385926751192637938686124570227538910606279104888073013, 11308837998867241929817950595621831002334468993828126438599805989088017326675963100044309448653090403889186401929445861220402556074702741108929442867300279, 9184622887414209361516593101129556569811888214607556630094969763910426953786020755838094184972397480276666170685926425137063559394969166216392939257091541, 12896400069515890897430087815982545671830645201023665112429779640768899091287291452408369445919464144390726200808875066389240126909811239597092893733457339, 11227025698697471809912850435140886785315702278826761054472525227951791647003561270585720797267604996360933395122286757099101227901032364782594523739698877, 8162123490656317490361880020667919072708091053716891870691544217490126444997503404094174246087938828993696335191488583306443577208796794274099282013427247, 13366989889442670291461262313757977600095962057470863475519088648267301129719953368943419562144276679400967122727554764013132918505564677243979978807323041, 9920857455945408588203972193444437533164351309299040911469275059092031755811492460585653948481522995557801781838215407648572999358456612525812067538372579, 7139402473546047825312503780125417567716958846513076797328672521987900978293260385267945187604725349720103672258987935569856239987227455748213833342843243, 13108142660294572752252393081421368493392921884487755391460006730258159004638343897340537616297811742032405724656497443006056456690449881719305597286675631, 13276762958403786077380090195631980415297280849950287990717193547481553124160398455403123819234755237450529090601858784999113026218918277529515287668651121, 12463094640052886550696551772104539361264529587569204472038955376345085195998921095774583176899949596998985033050547755235409943131811058035802010421860899, 11307743131694864808301935844724645695851330736969875190167422024500753079857478680029193758960169072890576310607053767920339034290416580654771095674487943, 10053742503547378455068966704402695956702795408343604912294923217443553169726438945982031485796964462946592530592946335569560364464958066521486506177193131, 9703695763451799125258961776229325510814289358679213305418559381901496449849584244211834872313767844996255556721041007654625153809128987422992102292472533, 8148189465927721940294369879439913703690047528695196368949823197675716174991296513758196009346701553643721225250628151384047219921709201619262393792138023, 9114150910964237818418367840207724528917302406836157928223872622442928604249864486858755737149640683259834299165900696585038569188627682022002709058902291, 12273514376180781903469287345188404399033432117915094289694407562166649079228640510678711431664410226301556172582177240184695103942141430877677144285616059, 8355005721684425514882933910286584148305344580589623112959517428993968438533866906223777778058096962333203237111245328436600994120168924143849685728268811, 8957883838807471492147480816683526636019698464133185237668243268667169800811696770484487123560197988448434475112352005768286417529319182162245840523697001, 12168542584724814356632409768687396920143300559579648963851924568387314914334359305942685551210180448419674060219496395116081866784918059237133414041227833, 12285935007930825571672128346804313607196190465690759870758278705086034778808662886056460827935986285259185071514490942831585313190946386878622608868345563, 7719913817859572377164973343651155934060296607908537845256755472465025202751239980758950094865067751407889569369974011139801401586939119147773466111699913]
cs = [3911325901261770731066343727353093385607196883601022244426857460074338420692610012414571623512152485474248169220030587839849722757773859682519433853455847, 4198555117325325874584019691418573071733167640213933749582347442518997588452211673143722179281773602455507001395983681009769848414007206268682184816168744, 4422173666634983234895098798813962037875417568235708524339826709271381748884936178371767574064794177416615710120223914725873239836121654705208614576413533, 3540260422555697887869627546208164711550015909378340105077652177481959576550678379723450981807556863572610759824660630418670546203733170058626755080797998, 6451498467498935201092514865627931677091078787997097414208430992183264950579022373372254486595458117887305393317663712337699331503725124287017134808484874, 3439629581963524351810430910737336124616316641656190641248434504621774235943514617301857917041111617104850245148746427180069743940612560718213177903427306, 4279468191481832212496939242093486044278976937965085475567008228061184947513156012369586970486543083130565628906296600553024574099481246534878242920637212, 4102135455518061133919027670571325279976222647984452353051395864554309521223498761823084717077102213648612826513661629599971609555235760152049549057234342, 329051927890365028889097463563711966673066795688728876214731188783168691555262156515161429328581094087585127929869064685419149676592073496155898360311360, 1674347209896897571502352451063188834938904430329951752111921115230349947823188121972980025563878887201507629419811736910690965020923751424101521816057970, 4779084317811375050159574994746297486592271247137823471375199626788956576998627181220489952507937768042501203098391966702297812537463211799837921684467541, 5240331815784322792144549873873658636726233093228415489098002982220769676718681132737794994708716389174162820721646744776624413735318240597745363490427584, 2689716894922604875455207695253665212853470308341743040957367957727155614199743562225147359614514189877983156892749669804800163252617480446565479990148021, 449708769594599088851244243076921016853502252396793496349534051273454215985560340288452398756880916680293627457774430655982228613348249480600180821975835, 1584603978331289335352997151059666773277943458357161051278658090420067023680231414255557805410288144092653121568766136372728095300982743309696347031121424, 4874260053151700374809337053763032489184725334196495160358275038586824027920238733886703163018450814805937363825223459277373073591021082276610135118976834, 3524374131362906900545297291947110177298862564718451821839794960169356082042548386553363480921097452902723033854749443288682983558847052843293666815425196, 6544123591499569232021913370293570477776709315008783531720886545784773471486769240711262562401683145937715612435213816372680189321141928790509490282629891, 4873861166228118967099569086478548167127431415017791678812419676791754466935832034870862000658789609084166891933970013849850146718379819943737269970654866, 4100817874436703071716655163972145036104985973164830547825929590871920825981241934633977227547934514142660786061291026657802357404024236287955309372489516, 343238276681348130286495167739162902430650061145485619903964358840996341335935043000395056684771452815629410388891486531126938900311458948803147120186532, 2683710724350412998770392318832434885304538325033159937379489319924346689197445720734209841902612235485016866254994045969716413020197296428323832404151182, 5909464641105704179999104311562416363090166762341644691188169716182958971270396007422581429813172933930581475771306034495224054972725230757675444731953480, 105593489999747649490909471306354863316673821363863362258853043970534652401274789197677558215188249074837829003335733211890211648501689656345824858507373, 4992379366542645691375959247465888889778118153982142100956809440855745659745235576280578316185469306620017845690312554043770651058126536040173113949524396, 6533456398244789907636779407045515567135195474284185379689518387558345997627435421582437390053234675991361808532278264077968540197407743744279106871716267, 5169360398767270275853790242315213671633880428212603766301308853363063092609582572957561138022806887895634140899640025570759919257615537375706008159680239, 203310740924699994885931266978520636166917734618272844754878785050509801614513144739164450834936178065792112797202959106365282699245578309060905297742706, 3143563289239398127009575193211845399079310618985464994769603542400451633289266080869317336163844517539211542909055869608349639432145332113320465388067087, 4016252180207572047405081190649590978593306403200098541033213590567723751195926093369984531729148621419589009515870336049849542537363832071754623330736088]
enc = 1315637864146686255246675143589215932218700984880749264689270214639479160648747323586062096067740047809798944996253169402675772469028914904598116394230426
ss=[1444695997149492190325503358748907180896428744501435959012446197804471238996228693169795874437240656170107638535797004901, 1710106002173551002425444054140394178956124023376657957303230765508377089074717746465653815466763654648249527857825569029, 2055313300434754785614061534661234769322543457763273072311107482412288908659564309179643251560799446038081677516598963457, 2529893752644237783483797815212946495982855556933204694011832676840091910035653685416019963608166318536749345810876453771, 2529138628117798443470937234045077945473928204906198619005287365776711527156367496383631463561676109741862230251586143377, 2262110335813452474430699656412885234503426852605393691899881796634211611052330735315181940758828054398894455017113733227, 2121889637450522029350552877626679809458662297228865521642554573119772081854990312156453774280770474194162502389497160327, 2529142548180563996394639773713532833480273727306125086719935756161917184911736806616267916075735106590544780324467585621, 1305329295536404276170448056500700469825272137020946460143963140200353157377196505556280067991447170875038122866415550101, 1552852098086060808737139123645915631099187828325664479373402352780546739207516108015428990851489119938061929818491926611, 1791104999803661806603955436215385390826508049741363470424060526111730352962999232609779584743853648363257676913487057757, 1899442479566327507595284152198923816070020299280413329026247522765072323119884753949208875377108001657197781777679291871, 1453541167592343188338822229691660044736912312708428492831729087255748263545506909467533920598337452593734393704376978807, 1839970255647517988033776502403781838348352314214922889121617450060735210741294955388142534936822274443404021805803333703, 1912160881436961130805854105580691921433605240682869508192604979038043884642959974735162453664737011078276186132003267537, 2543565462805293682479626661848772865479251641709980622442153819428251437133653745822570184749929330644293218076375940297, 2483083156651635774502843350477278413827965814754343098791424022880695703529884053363101276861390834327295178464586090169, 2003169101542395781256109850378099343661620656525906226012777618825679882882750121108967747380040440812305500025030472703, 1495306582962644344763635303973344887376634002664321023099433581011613385215984473933899539552759121449556619118213926953, 1475475640507405435263556560927151140961838107291429033550823738085598452588645697451453622811307836240178487270066202731, 1585296258758653869729779396633477768935787077644413518874111953612262499991020378795132976171831363612740565577673589949, 1751870981277054153889475362865184270808672777814739187606382420502953249942908536146994775691865449715881103437411562697, 2229385019858443633247567841668512226312552028112872103049568509800432132563139223600501334488455486995847787457023057543, 2509522757833822636876029295601980862244548996153272433687613093337042904569711801805004013230589715380175225102878772429, 1378538686540733061307578409608662896663843431656273949667551098986968433993734090533525999772678987014720821134447883279, 1615745464810222578868113006917238415594773977456189037245148298498578637163332628299020222221658719347173123797381998597, 2064151464294100789516756482456818746190321203565732371731029967136921201410297069827915522687620140104021460523804416353, 1711545496198775131056637405659683132417828376528113270088200929297233962942202546621239829931304134031695960814215807973, 1455761879282217336477189039622363054351048993520687962567785409775020556422692091664440576775863933336882803763246548923, 1880891423536411979565374334582143474888275578342367502429189125513290153271930355071969557105539679922217905887177950249]

prime=p
ma=rs
res = cs

W = matrix(ZZ, ma)
cc = vector(ZZ, res)
#LWE求解x
# Babai's Nearest Plane algorithm
def Babai_closest_vector(M, G, target):
    small = target
    for _ in range(5):
        for i in reversed(range(M.nrows())):
            c = ((small * G[i]) / (G[i] * G[i])).round()
            small -=  M[i] * c
    return target - small

A1 = matrix.identity(column)
Ap = matrix.identity(row) * prime
B = block_matrix([[Ap], [W]])
lattice = IntegerLattice(B, lll_reduce=True)
print("LLL done")
gram = lattice.reduced_basis.gram_schmidt()[0]
target = vector(ZZ, res)
re = Babai_closest_vector(lattice.reduced_basis, gram, target)
# print("Closest Vector: {}".format(re))

R = IntegerModRing(prime)
M = Matrix(R, ma)
M = M.transpose()

ingredients = M.solve_right(re)

#求出x后利用PH算法对flag进行还原，因为发现p-1可以分解，p是光滑阶
# x=6789891305297779556556571922812978922375073901749764215969003309869718878076269545304055843125301553103531252334876560433405451108895206969904268456786139
x=int(ingredients[0])
print(x)
m=x
c=enc
n=p

def r(h, g, N, p, qi):
    Zp = Zmod(p)
    h = pow(h, N//qi, p)
    g = pow(g, N//qi, p)
    ri = discrete_log(Zp(h), Zp(g))
    return int(ri)
m=x
c=enc
n=p

tmp_list=[2,3,193,877,2663,662056037,812430763,814584769,830092927,849943517,969016409,1000954193,1022090869,1048277339]

r_list = []
for qi in tmp_list:
    tmp = r(c,m,n-1,n,qi)
    print(tmp)
    r_list.append(tmp)
x = crt(r_list, tmp_list)

module = 1
for i in tmp_list:
    module *= i

while True:
    if int(x).bit_length()>304:
        print('fail')
        break
    if int(pow(m, x, n))==c:
        print('x =', x)
        print(long_to_bytes(x))
        break
    x += module
```

得到flag

```
NKCTF{70b1b709ce431682addb581596320007}
```



## Web

### sign_in(12 solves,166 points)

这题签到题，很简单，照着步骤来就行

先在题目的地址后面加上hint：`/www.zip`

下载对应的内容，得到hint：

90a9330c85d2567d7c83949956a85e9b.php

将其加到网址后，得到以下界面

![image-20240826210829129](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240826210829129.png)

题目让我们输入password，发现题目提示给出了一堆密码，我们直接一个一个试一下就可以了

尝试到1919时成功出现flag

![image-20240826210948013](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240826210948013.png)

```
flag{9d60c4b8-6202-449e-8efc-5283bd9529e9}
```



## Reverse

### 1_simple_xor(8 solves,217 points)

这题观察题目，是一个简单的脱壳加壳的re题，秒了

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // edx
  __int128 *v4; // rax
  char v5; // cl
  int v6; // eax
  const char *v7; // rcx
  __int128 Buf1[2]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v10; // [rsp+40h] [rbp-28h]
  __int16 v11; // [rsp+48h] [rbp-20h]
  char v12; // [rsp+4Ah] [rbp-1Eh]

  v10 = 0i64;
  memset(Buf1, 0, sizeof(Buf1));
  v11 = 0;
  v12 = 0;
  puts("enter your flag:");
  sub_1400010D0("%42s");
  v3 = 0;
  v4 = Buf1;
  do
  {
    v5 = v3++ + 85;
    *(_BYTE *)v4 ^= v5;
    v4 = (__int128 *)((char *)v4 + 1);
  }
  while ( v3 < 42 );
  v6 = memcmp(Buf1, &unk_140002240, 0x2Aui64);
  v7 = "good job";
  if ( v6 )
    v7 = "try again";
  puts(v7);
  return 0;
}
```

​    `v5 = v3++ + 85`表示做xor运算从85开始，递增

while循环代表，加壳操作需要经过42轮操作，说明我们有42个字符

  `v6 = memcmp(Buf1, &unk_140002240, 0x2Aui64)`代表了将我们的加壳结果与`&unk_140002240`处内存的值进行比较，如果相同才是加密成功，否则失败

在ida中找到对应的地址中存储的内容，进行反向解密即可

![image-20240825114623957](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240825114623957.png)

编写一个简单的py程序来进行逆向脱壳

```python
encrypted_flag = bytearray([
    0x33,0x3A,0x36,0x3F,0x22,0x3C,0x3A,0x6F,0x69,0x6C,0x3B,0x57,0x51,0x4F,0x56,0x50,
    0x04,0x51,0x4A,0x5C,0x5B,0x59,0x0D,0x41,0x0C,0x0C,0x0D,0x15,0x5C,0x13,0x17,0x4D,
    0x47,0x4E,0x12,0x4B,0x1D,0x1B,0x4B,0x4A,0x1C,0x03
])

FLAG_LENGTH = 42
XOR_BASE = 85

def decrypt_flag(encrypted):
    decrypted = bytearray(FLAG_LENGTH)
    for i in range(FLAG_LENGTH):
        decrypted[i] = encrypted[i] ^ (i + XOR_BASE)
    return decrypted.decode('utf-8')

if __name__ == "__main__":
    decrypted_flag = decrypt_flag(encrypted_flag)
    print(f"Decrypted flag: {decrypted_flag}")

```

得到flag

```
flag{fa342d70-54a7-423f-abbe-ad928e3da06a}
```



### 2_base64(6 solves,265 points)

这题很简单，一眼出。

F5反汇编后得到

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rax
  void *v4; // rbx
  __int64 v5; // r8
  int v6; // eax
  const char *v7; // rcx
  __int128 v9[2]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v10; // [rsp+40h] [rbp-28h]
  __int16 v11; // [rsp+48h] [rbp-20h]
  char v12; // [rsp+4Ah] [rbp-1Eh]

  v10 = 0i64;
  memset(v9, 0, sizeof(v9));
  v11 = 0;
  v12 = 0;
  puts("enter your flag:");
  sub_1400010E0("%42s", (const char *)v9);
  v3 = (void *)sub_1400011E0(v9, 42i64);
  v4 = v3;
  v5 = -1i64;
  do
    ++v5;
  while ( *((_BYTE *)v3 + v5) );
  if ( v5 != 56
    || (v6 = memcmp(v3, "zMXHz3S2nMiWogzMzI1IyMi1ltrMnJuTogyZzc0YmZeYnJvLmte3nwz9", 0x38ui64), v7 = "good job", v6) )
  {
    v7 = "try again";
  }
  puts(v7);
  free(v4);
  return 0;
}
```

前面啥的都不用看，看到字符串`zMXHz3S2nMiWogzMzI1IyMi1ltrMnJuTogyZzc0YmZeYnJvLmte3nwz9`，发现前面的ZMXH很像base64的flag开头

base64得

![image-20240825113131560](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240825113131560.png)

发现不太对

将字符串大小写互换，再base64就出来了

![image-20240825113733248](C:\Users\Lenovo\Desktop\NKCTF\NKCTF_WriteUp_By_Luhaozhhhe.assets\image-20240825113733248.png)

```
flag{66b08fff-bbb5-4f65-8f3d-231265e1175f}
```

